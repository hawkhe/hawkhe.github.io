<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>librbd on Hawk's Blog</title><link>https://hawkhe.github.io/tags/librbd/</link><description>Recent content in librbd on Hawk's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 28 Jul 2022 08:22:07 +0000</lastBuildDate><atom:link href="https://hawkhe.github.io/tags/librbd/index.xml" rel="self" type="application/rss+xml"/><item><title>Librbd学习2: 写I/O流程</title><link>https://hawkhe.github.io/post/librbd_io_stack/</link><pubDate>Thu, 28 Jul 2022 08:22:07 +0000</pubDate><guid>https://hawkhe.github.io/post/librbd_io_stack/</guid><description>写I/O处理流程图 先把自己根据I/O栈总结的流程图放上来，后续的分析以该图为基准，顺着这个图来查看具体流程能够加深理解:)
图中不同的阶段有不同的颜色，其中：
黄色部分，代表客户端程序主线程把写操作追加到工作队列的步骤 蓝色部分，为Image内置线程池中的worker线程从工作队列中取出一次(写)请求的步骤 绿色部分，为该写请求的处理在librbd层上的步骤 橙色部分，为该写请求的处理在librados层上的步骤 粉色部分，为osdc层中的处理步骤 灰色部分，为msg层中的处理，此次I/O流程图未展开 客户端侧写入流程 主要工作内容 Image.write实际上就是把相关请求的参数，丢入到image成员变量ctx维护的一个ImageRequestWQ类型的队列中。 ImageRequestWQ处理的主要工作： 对I/O进行了参数检查和裁剪 使用异步I/O接口(aio_write)实现了同步I/O(write)的功能 异步I/O(aio_write)中，把write请求打包为ImageDispatchSpec*类型的req，并调用PointerWQ.queue进行入列 PointerWQ的queue方法负责把item(req)追加到std::list类型的成员变量m_items的尾部，主要流程到此结束 调用librbd::Image中write方法 Image::write() ImageCtx *ictx = (ImageCtx *)ctx; // 调用imageContext的io_work_queue的write, io_work_queue是一个ImageRequestWQ类型。 return ictx-&amp;gt;io_work_queue-&amp;gt;write(ofs, len, bufferlist{bl}, 0); -&amp;gt; ImageRequestWQ&amp;lt;I&amp;gt;::write(); ImageRequestWQ中的流程 实际调用了ImageRequestWQ的aio_write方法，通过等待回调的方式实现同步效果
ImageRequestWQ&amp;lt;I&amp;gt;::write() m_queued_writes++; ThreadPool::PointerWQ&amp;lt;ImageDispatchSpec&amp;lt;I&amp;gt; &amp;gt;::queue(req); // 调用ThreadPool::PointerWQ的queue方法ImageRequestWQ&amp;lt;I&amp;gt;::write int r = clip_io(util::get_image_ctx(&amp;amp;m_image_ctx), off, &amp;amp;len); // 进行参数检查，并且当len越界时，裁剪len至size的最大有效值 C_SaferCond cond; AioCompletion *c = AioCompletion::create(&amp;amp;cond); // 构建异步IO完成时的回调 aio_write(c, off, len, std::move(bl), op_flags, false); -&amp;gt; ImageRequestWQ&amp;lt;I&amp;gt;::aio_write() // 调用aio_write异步写接口 r = cond.</description></item><item><title>Librbd学习1: 调试环境搭建</title><link>https://hawkhe.github.io/post/librbd_compile/</link><pubDate>Fri, 22 Jul 2022 04:42:07 +0000</pubDate><guid>https://hawkhe.github.io/post/librbd_compile/</guid><description>编译Ceph 编译环境
root@haosheng-dev2:~# cat /etc/lsb-release DISTRIB_ID=Ubuntu DISTRIB_RELEASE=20.04 DISTRIB_CODENAME=focal DISTRIB_DESCRIPTION=&amp;#34;Ubuntu 20.04 LTS&amp;#34; 下载Ceph源码
root@haosheng-dev2:/work# git clone --branch v15.2.16 https://github.com/ceph/ceph.git 下载源码依赖
root@haosheng-dev2:/work# cd ceph root@haosheng-dev2:/work/ceph# git submodule update --init --recursive 安装依赖包
root@haosheng-dev2:/work/ceph# ./install-deps.sh 因为后面需要使用gdb调试程序，故需要以debug模式进行编译
配置debug相关参数，并执行do_cmake.sh
root@haosheng-dev2:/work/ceph# ARGS=&amp;#34;-DCMAKE_C_FLAGS=-O0 -g3 -gdwarf-4 -DCMAKE_CXX_FLAGS=-O0 -g3 -gdwarf-4&amp;#34; ./do_cmake.sh -DWITH_MGR_DASHBOARD_FRONTEND=off cmake添加的参数的解释:
CMAKE_C_FLAGS=“-O0 -g3 -gdwarf-4” ： c 语言编译配置 CMAKE_CXX_FLAGS=“-O0 -g3 -gdwarf-4” ：c++ 编译配置 -O0 : 关闭编译器的优化，如果没有，使用GDB追踪程序时，大多数变量被优化,无法显示, 生产环境必须关掉 -g3 : 意味着会产生大量的调试信息 -gdwarf-4 : dwarf 是一种调试格式，dwarf-4 版本为4 执行编译
root@haosheng-dev2:/work/ceph# cd build root@haosheng-dev2:/work/ceph/build# make -j4 查看编译后的库文件</description></item></channel></rss>