<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>SimpleFS文件系统3: 挂载文件系统 | Hawk's Blog</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="内核模块加载 SimpleFS的核心功能都在内核态实现，使用前需要保证该模块已经加载到内核之中。
其入口代码实现在fs.c文件中，加载SimpleFS内核模块时，会调用到module_init函数注册的simplefs_init函数上。
module_init(simplefs_init); // 模块初始化 module_exit(simplefs_exit); // 模块退出 MODULE_LICENSE(&#34;Dual BSD/GPL&#34;); MODULE_AUTHOR(&#34;National Cheng Kung University, Taiwan&#34;); MODULE_DESCRIPTION(&#34;a simple file system&#34;); simplefs_init函数 simplefs_init函数是加载到内核时的入口函数，主要执行了以下功能:
simplefs_init() - simplefs_init_inode_cache() // 初始化文件系统根目录的inode - kmem_cache_create(, sizeof(struct simplefs_inode_info),...) // 申请内存 - register_filesystem(&simplefs_file_system_type) // 注册文件系统，并参数传入文件系统类型 注册文件系统时，传入的参数，以全局变量形式定义在fs.c中，填充了SimpleFS必要的一些信息:
static struct file_system_type simplefs_file_system_type = { .owner = THIS_MODULE, .name = &#34;simplefs&#34;, .mount = simplefs_mount, // 注册执行mount命令时的回调函数 .kill_sb = simplefs_kill_sb, // 注册执行umount时的回调函数 .fs_flags = FS_REQUIRES_DEV, .next = NULL, }; simplefs_mount函数 simplefs_mount函数是在注册文件系统时，作为参数传入的，当执行mount挂载一个文件系统时，会回调到该函数上来。
simplefs_mount函数中直接调用了mount_bdev()函数:"><meta name=generator content="Hugo 0.110.0"><meta name=robots content="noindex, nofollow"><link rel=stylesheet href=/ananke/css/main.min.css><meta property="og:title" content="SimpleFS文件系统3: 挂载文件系统"><meta property="og:description" content="内核模块加载 SimpleFS的核心功能都在内核态实现，使用前需要保证该模块已经加载到内核之中。
其入口代码实现在fs.c文件中，加载SimpleFS内核模块时，会调用到module_init函数注册的simplefs_init函数上。
module_init(simplefs_init); // 模块初始化 module_exit(simplefs_exit); // 模块退出 MODULE_LICENSE(&#34;Dual BSD/GPL&#34;); MODULE_AUTHOR(&#34;National Cheng Kung University, Taiwan&#34;); MODULE_DESCRIPTION(&#34;a simple file system&#34;); simplefs_init函数 simplefs_init函数是加载到内核时的入口函数，主要执行了以下功能:
simplefs_init() - simplefs_init_inode_cache() // 初始化文件系统根目录的inode - kmem_cache_create(, sizeof(struct simplefs_inode_info),...) // 申请内存 - register_filesystem(&simplefs_file_system_type) // 注册文件系统，并参数传入文件系统类型 注册文件系统时，传入的参数，以全局变量形式定义在fs.c中，填充了SimpleFS必要的一些信息:
static struct file_system_type simplefs_file_system_type = { .owner = THIS_MODULE, .name = &#34;simplefs&#34;, .mount = simplefs_mount, // 注册执行mount命令时的回调函数 .kill_sb = simplefs_kill_sb, // 注册执行umount时的回调函数 .fs_flags = FS_REQUIRES_DEV, .next = NULL, }; simplefs_mount函数 simplefs_mount函数是在注册文件系统时，作为参数传入的，当执行mount挂载一个文件系统时，会回调到该函数上来。
simplefs_mount函数中直接调用了mount_bdev()函数:"><meta property="og:type" content="article"><meta property="og:url" content="https://hawkhe.github.io/post/simplefs_mount/"><meta property="article:section" content="post"><meta property="article:published_time" content="2020-07-15T00:25:43+08:00"><meta property="article:modified_time" content="2020-07-15T00:25:43+08:00"><meta itemprop=name content="SimpleFS文件系统3: 挂载文件系统"><meta itemprop=description content="内核模块加载 SimpleFS的核心功能都在内核态实现，使用前需要保证该模块已经加载到内核之中。
其入口代码实现在fs.c文件中，加载SimpleFS内核模块时，会调用到module_init函数注册的simplefs_init函数上。
module_init(simplefs_init); // 模块初始化 module_exit(simplefs_exit); // 模块退出 MODULE_LICENSE(&#34;Dual BSD/GPL&#34;); MODULE_AUTHOR(&#34;National Cheng Kung University, Taiwan&#34;); MODULE_DESCRIPTION(&#34;a simple file system&#34;); simplefs_init函数 simplefs_init函数是加载到内核时的入口函数，主要执行了以下功能:
simplefs_init() - simplefs_init_inode_cache() // 初始化文件系统根目录的inode - kmem_cache_create(, sizeof(struct simplefs_inode_info),...) // 申请内存 - register_filesystem(&simplefs_file_system_type) // 注册文件系统，并参数传入文件系统类型 注册文件系统时，传入的参数，以全局变量形式定义在fs.c中，填充了SimpleFS必要的一些信息:
static struct file_system_type simplefs_file_system_type = { .owner = THIS_MODULE, .name = &#34;simplefs&#34;, .mount = simplefs_mount, // 注册执行mount命令时的回调函数 .kill_sb = simplefs_kill_sb, // 注册执行umount时的回调函数 .fs_flags = FS_REQUIRES_DEV, .next = NULL, }; simplefs_mount函数 simplefs_mount函数是在注册文件系统时，作为参数传入的，当执行mount挂载一个文件系统时，会回调到该函数上来。
simplefs_mount函数中直接调用了mount_bdev()函数:"><meta itemprop=datePublished content="2020-07-15T00:25:43+08:00"><meta itemprop=dateModified content="2020-07-15T00:25:43+08:00"><meta itemprop=wordCount content="349"><meta itemprop=keywords content="simplefs,fs,"><meta name=twitter:card content="summary"><meta name=twitter:title content="SimpleFS文件系统3: 挂载文件系统"><meta name=twitter:description content="内核模块加载 SimpleFS的核心功能都在内核态实现，使用前需要保证该模块已经加载到内核之中。
其入口代码实现在fs.c文件中，加载SimpleFS内核模块时，会调用到module_init函数注册的simplefs_init函数上。
module_init(simplefs_init); // 模块初始化 module_exit(simplefs_exit); // 模块退出 MODULE_LICENSE(&#34;Dual BSD/GPL&#34;); MODULE_AUTHOR(&#34;National Cheng Kung University, Taiwan&#34;); MODULE_DESCRIPTION(&#34;a simple file system&#34;); simplefs_init函数 simplefs_init函数是加载到内核时的入口函数，主要执行了以下功能:
simplefs_init() - simplefs_init_inode_cache() // 初始化文件系统根目录的inode - kmem_cache_create(, sizeof(struct simplefs_inode_info),...) // 申请内存 - register_filesystem(&simplefs_file_system_type) // 注册文件系统，并参数传入文件系统类型 注册文件系统时，传入的参数，以全局变量形式定义在fs.c中，填充了SimpleFS必要的一些信息:
static struct file_system_type simplefs_file_system_type = { .owner = THIS_MODULE, .name = &#34;simplefs&#34;, .mount = simplefs_mount, // 注册执行mount命令时的回调函数 .kill_sb = simplefs_kill_sb, // 注册执行umount时的回调函数 .fs_flags = FS_REQUIRES_DEV, .next = NULL, }; simplefs_mount函数 simplefs_mount函数是在注册文件系统时，作为参数传入的，当执行mount挂载一个文件系统时，会回调到该函数上来。
simplefs_mount函数中直接调用了mount_bdev()函数:"></head><body class="ma0 avenir bg-near-white"><header><div class=bg-black><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=/ class="f3 fw2 hover-white no-underline white-90 dib">Hawk's Blog</a><div class="flex-l items-center"><ul class="pl0 mr3"><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=/post/ title="Articles page">Articles</a></li></ul><div class=ananke-socials></div></div></div></nav></div></header><main class=pb7 role=main><article class="flex-l flex-wrap justify-between mw8 center ph3"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked">ARTICLES</aside><div id=sharing class="mt3 ananke-socials"></div><h1 class="f1 athelas mt3 mb1">SimpleFS文件系统3: 挂载文件系统</h1><time class="f6 mv4 dib tracked" datetime=2020-07-15T00:25:43+08:00>July 15, 2020</time></header><div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-100"><h2 id=内核模块加载>内核模块加载</h2><p>SimpleFS的核心功能都在内核态实现，使用前需要保证该模块已经加载到内核之中。</p><p>其入口代码实现在fs.c文件中，加载SimpleFS内核模块时，会调用到module_init函数注册的simplefs_init函数上。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>module_init</span>(simplefs_init); <span style=color:#75715e>// 模块初始化
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>module_exit</span>(simplefs_exit); <span style=color:#75715e>// 模块退出
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>MODULE_LICENSE</span>(<span style=color:#e6db74>&#34;Dual BSD/GPL&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>MODULE_AUTHOR</span>(<span style=color:#e6db74>&#34;National Cheng Kung University, Taiwan&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>MODULE_DESCRIPTION</span>(<span style=color:#e6db74>&#34;a simple file system&#34;</span>);
</span></span></code></pre></div><h2 id=simplefs_init函数>simplefs_init函数</h2><p>simplefs_init函数是加载到内核时的入口函数，主要执行了以下功能:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>simplefs_init</span>()
</span></span><span style=display:flex><span><span style=color:#f92672>-</span> <span style=color:#a6e22e>simplefs_init_inode_cache</span>() <span style=color:#75715e>// 初始化文件系统根目录的inode
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#f92672>-</span> <span style=color:#a6e22e>kmem_cache_create</span>(, <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> simplefs_inode_info),...) <span style=color:#75715e>// 申请内存
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>-</span> <span style=color:#a6e22e>register_filesystem</span>(<span style=color:#f92672>&amp;</span>simplefs_file_system_type) <span style=color:#75715e>// 注册文件系统，并参数传入文件系统类型
</span></span></span></code></pre></div><p>注册文件系统时，传入的参数，以全局变量形式定义在fs.c中，填充了SimpleFS必要的一些信息:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>struct</span> file_system_type simplefs_file_system_type <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    .owner <span style=color:#f92672>=</span> THIS_MODULE, 
</span></span><span style=display:flex><span>    .name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;simplefs&#34;</span>,
</span></span><span style=display:flex><span>    .mount <span style=color:#f92672>=</span> simplefs_mount, <span style=color:#75715e>// 注册执行mount命令时的回调函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    .kill_sb <span style=color:#f92672>=</span> simplefs_kill_sb, <span style=color:#75715e>// 注册执行umount时的回调函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    .fs_flags <span style=color:#f92672>=</span> FS_REQUIRES_DEV,
</span></span><span style=display:flex><span>    .next <span style=color:#f92672>=</span> NULL,
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h2 id=simplefs_mount函数>simplefs_mount函数</h2><p>simplefs_mount函数是在注册文件系统时，作为参数传入的，当执行mount挂载一个文件系统时，会回调到该函数上来。</p><p>simplefs_mount函数中直接调用了mount_bdev()函数:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> dentry <span style=color:#f92672>*</span><span style=color:#a6e22e>simplefs_mount</span>(<span style=color:#66d9ef>struct</span> file_system_type <span style=color:#f92672>*</span>fs_type,
</span></span><span style=display:flex><span>                              <span style=color:#66d9ef>int</span> flags,
</span></span><span style=display:flex><span>                              <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>dev_name,
</span></span><span style=display:flex><span>                              <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>data)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> dentry <span style=color:#f92672>*</span>dentry <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>mount_bdev</span>(fs_type, flags, dev_name, data, simplefs_fill_super);
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>mount_bdev是用来执行块设备挂载的函数，主要做了几件事情:</p><ul><li>根据设备名称dev_name，找到已经注册的块设备block_device。</li><li>根据文件系统类型fs_type，对应的块设备，找到或者新建一个超级块并返回指针。</li><li>如果超级块指针的s_root不为空，表明已经挂载过该文件系统，需要进行挂载flag的冲突判断等处理。</li><li>如果为空，表示首次挂载，则在指针中填充mode, id, blocksize属性后，调用传入的回调函数，对超级块进行后续的初始化过程。</li><li>最终返回文件系统根目录root的指针(dentry*)。</li></ul><h2 id=simplefs_fill_super函数>simplefs_fill_super函数</h2><p>mount_bdev函数最终会回调到SimpleFS的simplefs_fill_super函数上，进行超级块结构体的剩余的填充工作，并完成挂载操作。主要的步骤实现如下:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>simplefs_fill_super</span>(<span style=color:#66d9ef>struct</span> super_block <span style=color:#f92672>*</span>sb, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>data, <span style=color:#66d9ef>int</span> silent)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Init sb */</span>
</span></span><span style=display:flex><span>    sb<span style=color:#f92672>-&gt;</span>s_magic <span style=color:#f92672>=</span> SIMPLEFS_MAGIC; <span style=color:#75715e>// 设置预定义的魔数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>sb_set_blocksize</span>(sb, SIMPLEFS_BLOCK_SIZE); <span style=color:#75715e>// 跟新块大小
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    sb<span style=color:#f92672>-&gt;</span>s_maxbytes <span style=color:#f92672>=</span> SIMPLEFS_MAX_FILESIZE; <span style=color:#75715e>// 设置最大文件大小
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    sb<span style=color:#f92672>-&gt;</span>s_op <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>simplefs_super_ops; <span style=color:#75715e>// 实现super_operations中定义的接口，比如sync_fs, statfs等
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Read sb from disk */</span>
</span></span><span style=display:flex><span>    bh <span style=color:#f92672>=</span> <span style=color:#a6e22e>sb_bread</span>(sb, SIMPLEFS_SB_BLOCK_NR); <span style=color:#75715e>// 从块设备的第0号block中读取数据到buffer中(已设置blocksize)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    csb <span style=color:#f92672>=</span> (<span style=color:#66d9ef>struct</span> simplefs_sb_info <span style=color:#f92672>*</span>) bh<span style=color:#f92672>-&gt;</span>b_data; <span style=color:#75715e>// 指向块设备中存储的超级块信息
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Check magic number */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (csb<span style=color:#f92672>-&gt;</span>magic <span style=color:#f92672>!=</span> sb<span style=color:#f92672>-&gt;</span>s_magic) { <span style=color:#75715e>// 检查块设备读到的魔数，与软件定义的是否匹配(区分版本?)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>goto</span> release;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Alloc sb_info */</span>
</span></span><span style=display:flex><span>    sbi <span style=color:#f92672>=</span> <span style=color:#a6e22e>kzalloc</span>(<span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> simplefs_sb_info), GFP_KERNEL); <span style=color:#75715e>// 重新申请一块内存保存超级块信息
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    sbi<span style=color:#f92672>-&gt;</span>nr_blocks <span style=color:#f92672>=</span> csb<span style=color:#f92672>-&gt;</span>nr_blocks; <span style=color:#75715e>// 从buffer中拷贝数据填充到新分配的内存中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    sbi<span style=color:#f92672>-&gt;</span>nr_inodes <span style=color:#f92672>=</span> csb<span style=color:#f92672>-&gt;</span>nr_inodes;
</span></span><span style=display:flex><span>    sbi<span style=color:#f92672>-&gt;</span>nr_istore_blocks <span style=color:#f92672>=</span> csb<span style=color:#f92672>-&gt;</span>nr_istore_blocks;
</span></span><span style=display:flex><span>    sbi<span style=color:#f92672>-&gt;</span>nr_ifree_blocks <span style=color:#f92672>=</span> csb<span style=color:#f92672>-&gt;</span>nr_ifree_blocks;
</span></span><span style=display:flex><span>    sbi<span style=color:#f92672>-&gt;</span>nr_bfree_blocks <span style=color:#f92672>=</span> csb<span style=color:#f92672>-&gt;</span>nr_bfree_blocks;
</span></span><span style=display:flex><span>    sbi<span style=color:#f92672>-&gt;</span>nr_free_inodes <span style=color:#f92672>=</span> csb<span style=color:#f92672>-&gt;</span>nr_free_inodes;
</span></span><span style=display:flex><span>    sbi<span style=color:#f92672>-&gt;</span>nr_free_blocks <span style=color:#f92672>=</span> csb<span style=color:#f92672>-&gt;</span>nr_free_blocks;
</span></span><span style=display:flex><span>    sb<span style=color:#f92672>-&gt;</span>s_fs_info <span style=color:#f92672>=</span> sbi; <span style=color:#75715e>// 把通用的超级块结构体的s_fs_info属性指向SimpleFS定义的超级块信息中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>brelse</span>(bh); <span style=color:#75715e>// 释放buffer_head
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Alloc and copy ifree_bitmap */</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 以下部分把存储在设备中的ifree_bitmap拷贝到内存中，全部在内存中缓存起来
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    sbi<span style=color:#f92672>-&gt;</span>ifree_bitmap <span style=color:#f92672>=</span> <span style=color:#75715e>// inode空闲位图指针分配内存, 大小与块设备中一样，即块数目*块大小(4KB)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>kzalloc</span>(sbi<span style=color:#f92672>-&gt;</span>nr_ifree_blocks <span style=color:#f92672>*</span> SIMPLEFS_BLOCK_SIZE, GFP_KERNEL);
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> sbi<span style=color:#f92672>-&gt;</span>nr_ifree_blocks; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> idx <span style=color:#f92672>=</span> sbi<span style=color:#f92672>-&gt;</span>nr_istore_blocks <span style=color:#f92672>+</span> i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        bh <span style=color:#f92672>=</span> <span style=color:#a6e22e>sb_bread</span>(sb, idx); <span style=color:#75715e>// 根据块索引, 从块设备中读取数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        ...
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>memcpy</span>((<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>) sbi<span style=color:#f92672>-&gt;</span>ifree_bitmap <span style=color:#f92672>+</span> i <span style=color:#f92672>*</span> SIMPLEFS_BLOCK_SIZE, bh<span style=color:#f92672>-&gt;</span>b_data,
</span></span><span style=display:flex><span>               SIMPLEFS_BLOCK_SIZE); <span style=color:#75715e>// 填充到ifree_bitmap指针对应的offset上
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        ...
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Alloc and copy bfree_bitmap */</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 与ifree_bitmap类似，以下部分拷贝bfree_bitmap
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    sbi<span style=color:#f92672>-&gt;</span>bfree_bitmap <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>kzalloc</span>(sbi<span style=color:#f92672>-&gt;</span>nr_bfree_blocks <span style=color:#f92672>*</span> SIMPLEFS_BLOCK_SIZE, GFP_KERNEL);
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> sbi<span style=color:#f92672>-&gt;</span>nr_bfree_blocks; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> idx <span style=color:#f92672>=</span> sbi<span style=color:#f92672>-&gt;</span>nr_istore_blocks <span style=color:#f92672>+</span> sbi<span style=color:#f92672>-&gt;</span>nr_ifree_blocks <span style=color:#f92672>+</span> i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        bh <span style=color:#f92672>=</span> <span style=color:#a6e22e>sb_bread</span>(sb, idx);
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>memcpy</span>((<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>) sbi<span style=color:#f92672>-&gt;</span>bfree_bitmap <span style=color:#f92672>+</span> i <span style=color:#f92672>*</span> SIMPLEFS_BLOCK_SIZE, bh<span style=color:#f92672>-&gt;</span>b_data,
</span></span><span style=display:flex><span>               SIMPLEFS_BLOCK_SIZE);
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Create root inode */</span>
</span></span><span style=display:flex><span>    root_inode <span style=color:#f92672>=</span> <span style=color:#a6e22e>simplefs_iget</span>(sb, <span style=color:#ae81ff>0</span>); <span style=color:#75715e>//因为0号inode在格式化时已经写入信息到块设备，故从块设备读取数据并填充内存即可。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    ...
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>inode_init_owner</span>(root_inode, NULL, root_inode<span style=color:#f92672>-&gt;</span>i_mode);
</span></span><span style=display:flex><span>    sb<span style=color:#f92672>-&gt;</span>s_root <span style=color:#f92672>=</span> <span style=color:#a6e22e>d_make_root</span>(root_inode); <span style=color:#75715e>// 使用根inode创建对应的dentry，并填充到超级块的s_root
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    ...
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>// 异常处理
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>... 
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>至此，超级块的信息已经填充完毕，也就相应地完成了挂载的主要工作。</p><p>到这里，我们已经积累了足够多的经验，能够进一步探索SimpleFS是如何进行I/O操作的了。</p><ul class=pa0><li class="list di"><a href=/tags/simplefs/ class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">simplefs</a></li><li class="list di"><a href=/tags/fs/ class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">fs</a></li></ul><div class="mt6 instapaper_ignoref"></div></div><aside class="w-30-l mt6-l"><div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links"><p class="f5 b mb3">Related</p><ul class="pa0 list"><li class=mb2><a href=/post/simplefs_mkfs/>SimpleFS文件系统2: 格式化</a></li><li class=mb2><a href=/post/simplefs_compile/>SimpleFS文件系统1: 初次使用</a></li></ul></div></aside></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://hawkhe.github.io/>&copy; Hawk's Blog 2023</a><div><div class=ananke-socials></div></div></div></footer></body></html>