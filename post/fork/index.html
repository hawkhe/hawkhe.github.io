<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>使用系统调用fork创建子进程 | Hawk's Blog</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="上一篇文章中，在使用strace跟踪demo程序系统调用时，不知道小伙伴们有没有发现一个小细节。"><meta name=generator content="Hugo 0.110.0"><meta name=robots content="noindex, nofollow"><link rel=stylesheet href=/ananke/css/main.min.css><meta property="og:title" content="使用系统调用fork创建子进程"><meta property="og:description" content="上一篇文章中，在使用strace跟踪demo程序系统调用时，不知道小伙伴们有没有发现一个小细节。"><meta property="og:type" content="article"><meta property="og:url" content="https://hawkhe.github.io/post/fork/"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-02-20T06:23:37+00:00"><meta property="article:modified_time" content="2023-02-20T06:23:37+00:00"><meta itemprop=name content="使用系统调用fork创建子进程"><meta itemprop=description content="上一篇文章中，在使用strace跟踪demo程序系统调用时，不知道小伙伴们有没有发现一个小细节。"><meta itemprop=datePublished content="2023-02-20T06:23:37+00:00"><meta itemprop=dateModified content="2023-02-20T06:23:37+00:00"><meta itemprop=wordCount content="274"><meta itemprop=keywords content="syscall,"><meta name=twitter:card content="summary"><meta name=twitter:title content="使用系统调用fork创建子进程"><meta name=twitter:description content="上一篇文章中，在使用strace跟踪demo程序系统调用时，不知道小伙伴们有没有发现一个小细节。"></head><body class="ma0 avenir bg-near-white"><header><div class=bg-black><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=/ class="f3 fw2 hover-white no-underline white-90 dib">Hawk's Blog</a><div class="flex-l items-center"><ul class="pl0 mr3"><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=/post/ title="Articles page">Articles</a></li></ul><div class=ananke-socials></div></div></div></nav></div></header><main class=pb7 role=main><article class="flex-l flex-wrap justify-between mw8 center ph3"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked">ARTICLES</aside><div id=sharing class="mt3 ananke-socials"></div><h1 class="f1 athelas mt3 mb1">使用系统调用fork创建子进程</h1><time class="f6 mv4 dib tracked" datetime=2023-02-20T06:23:37Z>February 20, 2023<ul class=pa0>Tags:<li class="list di"><a href=/tags/syscall/ class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">syscall</a></li></ul></time></header><div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-100"><p>上一篇文章中，在使用strace跟踪demo程序系统调用时，不知道小伙伴们有没有发现一个小细节。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>root@hao6:~# strace ./demo
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>brk<span style=color:#f92672>(</span>0x560d8b593000<span style=color:#f92672>)</span>                     <span style=color:#f92672>=</span> 0x560d8b593000
</span></span><span style=display:flex><span>futex<span style=color:#f92672>(</span>0x7f763abc977c, FUTEX_WAKE_PRIVATE, 2147483647<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>clone<span style=color:#f92672>(</span>child_stack<span style=color:#f92672>=</span>NULL, flags<span style=color:#f92672>=</span>CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr<span style=color:#f92672>=</span>0x7f763a66ea10<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>99202</span>
</span></span><span style=display:flex><span>wait4<span style=color:#f92672>(</span>99202, NULL, 0, NULL<span style=color:#f92672>)</span>             <span style=color:#f92672>=</span> <span style=color:#ae81ff>99202</span>
</span></span><span style=display:flex><span>--- SIGCHLD <span style=color:#f92672>{</span>si_signo<span style=color:#f92672>=</span>SIGCHLD, si_code<span style=color:#f92672>=</span>CLD_EXITED, si_pid<span style=color:#f92672>=</span>99202, si_uid<span style=color:#f92672>=</span>0, si_status<span style=color:#f92672>=</span>1, si_utime<span style=color:#f92672>=</span>0, si_stime<span style=color:#f92672>=</span>0<span style=color:#f92672>}</span> ---
</span></span><span style=display:flex><span>newfstatat<span style=color:#f92672>(</span>0, <span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#f92672>{</span>st_mode<span style=color:#f92672>=</span>S_IFCHR|0600, st_rdev<span style=color:#f92672>=</span>makedev<span style=color:#f92672>(</span>0x88, 0x4<span style=color:#f92672>)</span>, ...<span style=color:#f92672>}</span>, AT_EMPTY_PATH<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><h2 id=问题>问题</h2><p>那就是我们的demo程序，使用的是fork函数来创建子进程，但是系统调用里面并没有使用fork，而是使用的clone。</p><p>我们去对应版本glibc中一探究竟，首先找到glibc的版本，</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>root@hao6:~# ldd --version | grep -i glibc
</span></span><span style=display:flex><span>ldd <span style=color:#f92672>(</span>Ubuntu GLIBC 2.35-0ubuntu3.1<span style=color:#f92672>)</span> 2.35
</span></span></code></pre></div><p>在nptl/sysdeps/unix/sysv/linux/fork.c文件中，找到了fork在linux系统下的实现，</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>pid_t</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>__libc_fork</span> (<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=color:#75715e>#ifdef ARCH_FORK  </span><span style=color:#75715e>// 如果定义了ARCH_FORK，则调用它
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  pid <span style=color:#f92672>=</span> <span style=color:#a6e22e>ARCH_FORK</span> ();
</span></span><span style=display:flex><span><span style=color:#75715e>#else  </span><span style=color:#75715e>// 否则，调用fork的系统调用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e># error &#34;ARCH_FORK must be defined so that the CLONE_SETTID flag is used&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  pid <span style=color:#f92672>=</span> <span style=color:#a6e22e>INLINE_SYSCALL</span> (fork, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>...
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>weak_alias</span> (__libc_fork, fork)
</span></span></code></pre></div><p>ARCH_FORK有多个操作系统版本的定义，这里找到了测试环境所使用的x86_64中的定义，</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// nptl/sysdeps/unix/sysv/linux/x86_64/fork.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define ARCH_FORK() \
</span></span></span><span style=display:flex><span><span style=color:#75715e>  INLINE_SYSCALL (clone, 4,						      \
</span></span></span><span style=display:flex><span><span style=color:#75715e>		  CLONE_CHILD_SETTID | CLONE_CHILD_CLEARTID | SIGCHLD, 0,     \
</span></span></span><span style=display:flex><span><span style=color:#75715e>		  NULL, &amp;THREAD_SELF-&gt;tid)
</span></span></span></code></pre></div><p>可以看出，ARCH_FORK实际上是在这里最终调用了clone的系统调用。而这里设置的3个flag，也与strace中看到的一致，那这次静态分析翻车的概率应该就不大了。。</p><h2 id=调用fork>调用fork</h2><p>如果小伙伴们要问，我就是要调用fork，不用clone，该怎么办呢？</p><p>参考网上大神给出的方法，绕过glibc，直接嵌入汇编代码。</p><p>这里要先找到fork系统调用的编号，可见其为57号，</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>root@hao6:/work# grep <span style=color:#e6db74>&#39;fork&#39;</span> linux-5.15.94/arch/x86/entry/syscalls/syscall_64.tbl
</span></span><span style=display:flex><span><span style=color:#ae81ff>57</span>      common  fork                    sys_fork
</span></span><span style=display:flex><span><span style=color:#ae81ff>58</span>      common  vfork                   sys_vfork
</span></span></code></pre></div><p>这里更新一下demo代码，</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/wait.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>using namespace std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>pid_t</span> pid;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>asm</span>(<span style=color:#e6db74>&#34;mov $57, %rax&#34;</span>);  <span style=color:#75715e>// 设置rax寄存器为57
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>asm</span>(<span style=color:#e6db74>&#34;syscall&#34;</span>);  <span style=color:#75715e>// 调用fork()生成子进程
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>asm</span>(<span style=color:#e6db74>&#34;movl %%eax, %0&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;=m&#34;</span> (pid));  <span style=color:#75715e>// 赋值返回值到pid
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (pid <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Error creating&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>exit</span>(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (pid <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) <span style=color:#75715e>// 如果是子进程
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;This is child: %i</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>getpid</span>());
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>exit</span>(<span style=color:#ae81ff>1</span>); <span style=color:#75715e>// 直接退出，造成zombie状态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#75715e>// 如果是父进程
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;This is parent: %i</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>getpid</span>());
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>waitpid</span>(pid, nullptr, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> a;
</span></span><span style=display:flex><span>        cin <span style=color:#f92672>&gt;&gt;</span> a;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这里用到了asm的扩展格式，查看资料简单梳理一下，其指令格式为:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>asm</span> [<span style=color:#66d9ef>volatile</span>] (<span style=color:#e6db74>&#34;汇编指令&#34;</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;输出操作数列表&#34;</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;输入操作数列表&#34;</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;改动的寄存器&#34;</span>);
</span></span></code></pre></div><p>其中，</p><ul><li>输出操作数列表：汇编代码如何把处理结果传递到 C 代码中</li><li>输入操作数列表：C 代码如何把数据传递给内联汇编代码</li><li>改动的寄存器：告诉编译器，在内联汇编代码中，我们使用了哪些寄存器。指定这个是为了避免编译器在使用寄存器的时候，与我们的asm指令冲突了。</li></ul><p>其中，输出和输入操作数列表的格式也是固定的，</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#e6db74>&#34;[输出修饰符]约束&#34;</span>(<span style=color:#960050;background-color:#1e0010>寄存器或内存地址</span>)
</span></span></code></pre></div><p>输出修饰符是可选的，主要是用来对输出寄存器或内存进行额外的说明，</p><ul><li>+：被修饰的操作数可以读取，可以写入；</li><li>=：被修饰的操作数只能写入；</li><li>%：被修饰的操作数可以和下一个操作数互换；</li><li>&：在内联函数完成之前，可以删除或者重新使用被修饰的操作数；</li></ul><p>约束就是告诉编译器，使用约束了范围的寄存器或内存，</p><ul><li>a: 使用 eax/ax/al 寄存器；</li><li>b: 使用 ebx/bx/bl 寄存器；</li><li>c: 使用 ecx/cx/cl 寄存器；</li><li>d: 使用 edx/dx/dl 寄存器；</li><li>r: 使用任何可用的通用寄存器；</li><li>m: 使用变量的内存位置；</li></ul><p>写到这里，也就不难理解demo中的asm扩展用法了。</p><h2 id=验证>验证</h2><p>我们再执行下demo程序，</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>root@hao6:~# ./demo 
</span></span><span style=display:flex><span>This is parent: <span style=color:#ae81ff>105000</span>
</span></span><span style=display:flex><span>This is child: <span style=color:#ae81ff>105001</span>
</span></span></code></pre></div><p>发现了子进程中对其pid的打印，与父进程不一样，可以确定我们已经成功使用嵌入的汇编代码，执行了fork的系统调用。</p><h2 id=引用>引用</h2><p><a href=https://www.cnblogs.com/sewain/p/14707347.html>内联汇编很可怕吗？看完这篇文章，终结它！</a></p><div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links"><p class="f5 b mb3">Related</p><ul class="pa0 list"><li class=mb2><a href=/post/waitpid/>使用waitpid收割僵尸进程</a></li></ul></div><div class="mt6 instapaper_ignoref"></div></div></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://hawkhe.github.io/>&copy; Hawk's Blog 2023</a><div><div class=ananke-socials></div></div></div></footer></body></html>